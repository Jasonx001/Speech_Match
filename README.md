# Speech_Match
This reposotory release a simple C++ Project, which implements a Speech Match,
## 1、程序要求

### 1.1 比赛规则

-   学校举行一场演讲比赛，共12个人参加，共比赛两轮，第一轮为淘汰赛，第二轮为决赛
-   每名选手都有对应的编号，如10001~10012
-   比赛方式：分组比赛，每组6个人
-   第一轮比赛分为两个小组，按照所有选手的编号进行抽签，按抽签顺序进行演讲
-   十个评委给每名选手打分，去除最高分和最低分，求得平均分为本轮选手的成绩
-   当小组演讲完后，淘汰组内排名最后的三个选手，前三名晋级，进入下一轮
-   第二轮为决赛，前三名胜出
-   每轮比赛过后需要显示晋级选手的信息

### 1.2  程序功能

1.  开始演讲比赛：完成整届的比赛流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段
2.  查看往届记录：查看之前比赛的冠亚季军的比赛成绩，每次比赛都会记录到文件中，文件保存为.csv格式
3.  清空比赛记录：将文件中的数据清空
4.  退出比赛程序

### 1.3 功能分析

这几种功能可以用一个条件语句(switch)来控制：用户输入对应的数字，程序执行相应的功能。

这几种功能由一个管理员(Manager)来控制，定义一个管理员类，为管理员实现开始演讲比赛start_Match()、查看往届记录show_Record()、清空比赛记录clear_Record()和退出比赛程序exit_System()的功能。

## 2、开始演讲比赛--功能

开始演讲比赛这个功能其实控制了两轮的比赛流程和比赛结果的存储。

比赛流程：抽签 ---> 比赛(评委打分) ---> 晋级 ---> 抽签 ---> 比赛(评委打分) ---> 冠亚季军 ---> 比赛结束，保存冠亚季军的编号、成绩信息

​		比赛开始前，管理员需要准备数据，（a）12名选手的编号，这里用vector容器v_fst容器存储第一轮比赛所用的选手编号。(b) 存储选手编号和对应选手的map容器m_spkr，以编号为键，选手对象为值，每个选手有对应的名字和对应的存储两轮分数的列表。这里需要构建一个选手类，要求保留对选手成绩列表的读写功能。(c) 第一轮比赛结束后，存储两组前三名选手编号的vector容器v_scd。(d) 第二轮比赛结束后，存储冠亚季军编号的vector容器v_vct。

### 2.1抽签
   进行比赛时，管理员则需要对选手的编号进行抽签，因为两轮比赛都需要抽签，而且抽签的人数不同，所以管理员需要记录是第几轮比赛m_round。抽签功能其实是面对参加本轮比赛的选手的编号信息，对编号做一个乱序，即可实现抽签。
### 2.2 比赛
  抽签之后，容器内的元素已经乱序，开始通过访问容器中的编号，来让每个选手进行对应轮数的比赛。若是第一轮比赛，则六个选手为一组进行排名，组内前三名晋级，晋级选手编号保存至v_scd中。若是第二轮，则将组内前三名选手编号保存至v_vct中。比赛过程中，有10名评委为选手进行打分，打分之后对分数进行排序sort，去除最高分和最低分(这两个元素在容器两端，deque容器刚好可以从两端删除这两个数据，所以用deque容器临时存储当前选手的评委打分结果)，计算平均分，并将本轮的得分写入选手的分数列表。又因为比赛要分小组进行，还需要拿到每组的前三名选手编号，所以另定义一个multimap容器，以选手分数为键，编号为值，按分数降序排列。当比赛人数达到6人，取出容器中分数排名前三的选手编号，根据轮数放入v_scd或者v_vct中，执行完毕就清空该容器.
### 2.3保存比赛结果
比赛结束后根据v_vct中的冠亚季军的编号，将选手的编号、分数存储至.csv文件中。保存之后，比赛记录就已经不为空了，这里需要对属性record_Empty置为false。

## 3、显示往届记录
在开始比赛前，管理员需要查看往届记录，并在要求显示的时候提供显示。往届记录存储在.csv文件中，若文件为空或不存在则需要提示。这里需要注意的是，在进行完一次比赛后，.csv文件已经发生了改变，这时需要重新读取文件。因此在比赛开始前和每进行完一次比赛，都需要重新读取比赛记录文件。并对根据读取结果对属性record_Empty置为真或假。

## 4、删除往届记录
首先管理员需要知道记录是否为空。具体删除方式为：ofs对象以trunc方式打开文件就会清空文件。清空之后，对record_Empty赋值为真。
